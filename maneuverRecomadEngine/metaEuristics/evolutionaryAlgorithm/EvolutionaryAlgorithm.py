from maneuverRecomadEngine.metaEuristics.evolutionaryAlgorithm.Element import Element
import random


class EvolutionaryAlgorithm:
    def __init__(self, population_size, init_elements_from_cp_number, max_generations, max_stagnation_generations,
                 problem, EPSILON,  probability_to_add_a_new_vm, availableOffers_CP):
        """
        :param population_size: the number of the elements in the population
        :param max_generations: max generation for algorithm repetation
        :param max_stagnation_generations: max number of generation for which no improvement of best solution is observed
        :param mutation_rate: mutation probability
        :param solution_repair_trays: number of trays to repair a constraint
        :param problem: the problem description
        """
        self.maxGenerations = max_generations
        self.maxStagnationGenerations = max_stagnation_generations
        self.nrOfElementsInitializedWithCP = init_elements_from_cp_number
        self.population = []
        self.populationSize = population_size
        self.problem = problem
        self.bestElement = None
        self.stagnationSteps = 0
        self.EPSILON = EPSILON #0.1 value used to calculate frequency vector
        self.probability_to_add_a_new_vm = probability_to_add_a_new_vm #used if no mutation suceed try to add a new machine
        self.availableOffers_CP = availableOffers_CP #used in CP Initialization

        #some variables for statatistics
        self.doneIterations = 0
        self.successMuations = 0
        self.sucessMutationCP = 0
        self.betterSolutionFromMutationCP = 0



    def run(self):
        """
        EA algorithm body
        :return:
        """

        self.__initialization_CP_informate()
        for el in self.population:
            el.repair()
            el.eval()

        it = 0
        while it < self.maxGenerations and self.stagnationSteps < self.maxStagnationGenerations:
            it += 1

            self.problem.logger.debug("Generation: {}  mutate {} ".format(it, len(self.population)))
            for i in range(len(self.population)):
                 mutated_element, mutation_success = self.__mutate(self.population[i], 10)
                 mutated_element.repair()
                 mutated_element.eval()
                 self.population[i] = self.__select(self.population[i], mutated_element, True, mutation_success)

            self.getSolution()

        #self.problem.logger.info("Best solution")
        bestSol = self.getSolution()
        print("cost: ", bestSol)
        #print("elementCost", self.bestElement.elementCost, "cost:", self.bestElement.vmsPrice)
        #print(self.bestElement.buildSolutinInformations())
        #print("iterations: ", it, " stagnation: ", self.stagnationSteps)

        for el in self.population:
            self.successMuations += el.numberOfSucessMutations
            # print("success mutations:", el.numberOfSucessMutations, " howManyTimesANewElemetIsCreatedFromCurrentOne:",
            #       el.howManyTimesANewElemetIsCreatedFromCurrentOne, " element cost list: ", el.priceList)
        self.doneIterations = it


    def __initialization_CP_informate(self):
        """
        Init population:
           - random solution
           - solutions generated by constraints programming (solution number is found in nrOfElementsInitializedWithCP)
        :return:
        """
        # rezolvam problema fara constrangeri hard???

        strategies = ["FIRST_UNBOUND_MIN", "FIRST_UNBOUND_RANDOM",\
                      "RANDOM_MIN",  "RANDOM_RANDOM"]

        #"FIRST_UNBOUND_MAX", "RANDOM_MAX",
        allocationsList = []

        for strategy in strategies:
            runningTime, vnNr, vms, allocations = self.problem.solveCP(strategy, self.nrOfElementsInitializedWithCP, False, None, 10000)
            allocationsList += allocations

        for allocation in allocationsList:
            element = Element(self.problem)
            for i in range(len(allocation)):
                for j in range(len(allocation[0])):
                    if allocation[i][j] == 1:
                        element.addCompToVM(i, j)
            self.population.append(element)

        #print("!!!!!!!!!!!!!!!!!!" , range(self.populationSize - self.nrOfElementsInitializedWithCP))

        for i in range(self.populationSize - self.nrOfElementsInitializedWithCP*len(strategies)):
            element = Element(self.problem)
            element.initBasedOnMinimumComponentsNumber()
            self.population.append(element)
            #print(len(element.vms))



    class VM:
        """
        Helper class for mutation in order to calculate and store the information about the number of components on
        a VM and how many configurations it satisfy
        """
        def __init__(self, _id):
            self.id = _id
            self.nrOfComponents = 0
            self.frequencyMostLoadedComponents = []
            self.frequencyLessLoadedComponents = []

    def __proportional_selection_vm(self, vm_vector, mostLoaded):
        """

        :param vm_vector: a list of type EvolutionaryAlgorithm.VM
        :param mostLoaded: boolean value representing what type of selection you want to favor: from most loaded VM(true)
                or from less loaded VM (false)
        :return: selected VM id
        """
        r = random.random()
        frequency = []
        for vm in vm_vector:
            if mostLoaded:
                frequency.append(vm.frequencyMostLoadedComponents)
            else:
                frequency.append(vm.frequencyLessLoadedComponents)
        s = frequency[0]
        i = 0
        while (s < r) and (i < len(vm_vector) - 1):

            i += 1
            s += frequency[i]
        return vm_vector[i].id

    def __uniform_selection_vm(selfself, vm_vector):
        """
        Random uniform selection of a VM
        :param vm_vector: a list of type EvolutionaryAlgorithm.VM
        :return: selected VM id
        """
        index = int(random.random() * len(vm_vector))
        return vm_vector[index].id

    def __proportional_selection_comp_from_vm(self, _comps):
        frequences = []
        compsId = []
        s = 0.0
        # print("comps:", _comps)
        _max = self.problem.componentsList[_comps[0]].numberOfConflictComponents
        _min = _max
        for compId in _comps:
            nr_of_conflicts = self.problem.componentsList[compId].numberOfConflictComponents
            #print(nr_of_conflicts)
            frequences.append(nr_of_conflicts)
            s += nr_of_conflicts
            if _max < nr_of_conflicts:
                _max = nr_of_conflicts
            compsId.append(compId)

        # print("frec sel comp: ", frequences)

        #print("frec sel comp: ", frequences)
        if s == 0:
            compNr = len(_comps)
            for i in range(compNr):
                frequences[i] = 1. / compNr
        else:
            #EPSILON = 0.1#in order to correct components with maximum conflict nr
            compNr = len(_comps)
            s = 0
            for i in range(len(frequences)):
                frequences[i] = (_max - frequences[i] + self.EPSILON)
                s += frequences[i]
            #print(frequences, s)
            for i in range(len(frequences)): # in [EPSILON,1]
                frequences[i] /= s

        r = random.random()
        s = frequences[0]
        i = 0
        #print("frec sel comp: ", frequences, r)
        while (s < r) and (i <= len(frequences)):
            #print("s=",s,"r=",r, "i=",i)
            i += 1
            s += frequences[i]
        return _comps[i]


    def mutation_with_cp(self, mostLoadedVmId, element):
        """
        Use CP to split most loaded VM
        :param mostLoadedVmId: the vmId with most components
        :param element: the mutated_element
        :return: True if a solution is found
        """
        # analyze components deployed on that machine
        # 1. full deployment
        # 2. collocation
        componentsThatCouldBeMoved = set()
        for compId in element.solVms[mostLoadedVmId]:
            if not self.problem.componentsList[compId].fullDeployedComponent:  # nu e full deployment
                #if len(self.problem.componentsList[compId].dependenceComponentsList) == 0:  # nu trebuie colocata cu alta componenta
                    componentsThatCouldBeMoved.add(compId)

        if len(componentsThatCouldBeMoved) > 1:
            # ne uitam daca putem sa modificam numarul total de masini
            newVmNr = min(len(element.vms) - 1 + len(componentsThatCouldBeMoved), self.problem.nrVM)

            #acu incepe cp-ul
            from maneuverRecomadEngine.exactsolvers import CP_Solver_GOT
            # cpSolver = CP_Solver_GOT.CP_Solver_Got(self.problem, "RANDOM_MIN", 100000000, True,
            #                                        self.availableOffers_CP, 100000000000, newVmNr)
            cpSolver = CP_Solver_GOT.CP_Solver_Got(self.problem, "RANDOM_MIN", 2, True,
                                                   self.availableOffers_CP, 1000, newVmNr)

            for restriction in self.problem.restrictionsList:
                restriction.generateRestrictions(cpSolver)

            vmIndex = 0
            for vmId in element.vms:
                if vmId != mostLoadedVmId:
                    for compId in element.solVms[vmId]:
                        cpSolver.addFixComponentRestriction(compId, vmIndex)
                    vmIndex += 1

            #print (mostLoadedVmId, componentsThatCouldBeMoved, newVmNr, element.a)

            objectiveValue, _costVector, _vm, allocation = cpSolver.run()
            print("@@@@@@@@@@", objectiveValue, _costVector, _vm, allocation)



        #aici pornesc de la problema initiala de cp
            if len(allocation) > 0: # a gasit o noua solutie
                element.reset_solution_initialization()
                for i in range(len(allocation)):
                    for j in range(len(allocation[0])):
                        if allocation[i][j] == 1:
                            element.addCompToVM(i, j)
                return True, element
        return False, element

    def __sortCriteria(self, lst):
        return lst[1]

    def mutation_with_cp_addConflict(self, mostLoadedVmId, element):
        """ - bin packing
        Use CP to split most loaded VM
        :param mostLoadedVmId: the vmId with most components
        :param element: the mutated_element
        :return: True if a solution is found
        """
        # analyze components deployed on that machine
        # 1. full deployment
        # 2. collocation
        componentsThatCouldBeMoved = set()
        for compId in element.solVms[mostLoadedVmId]:
            if not self.problem.componentsList[compId].fullDeployedComponent:  # nu e full deployment
                #if len(self.problem.componentsList[compId].dependenceComponentsList) == 0:  # nu trebuie colocata cu alta componenta
                    componentsThatCouldBeMoved.add(compId)

        if len(componentsThatCouldBeMoved) > 1:
            # ne uitam daca putem sa modificam numarul total de masini
            #newVmNr = len(element.vms) + len(componentsThatCouldBeMoved) #daca masinile sunt identice si pun conflicte intre 2 atunci imi trebuie mai multe
            newVmNr = self.problem.nrVM
            #acu incepe cp-ul
            from maneuverRecomadEngine.exactsolvers import CP_Solver_GOT
            cpSolver = CP_Solver_GOT.CP_Solver_Got(self.problem, "RANDOM_MIN", 4, True,
                                                   None, 1000, newVmNr)

            for restriction in self.problem.restrictionsList:
                restriction.generateRestrictions(cpSolver)


            vmIndex = 0
            for vmId in element.vms:
                if vmId != mostLoadedVmId:
                    for compId in element.solVms[vmId]:
                        if compId not in componentsThatCouldBeMoved:
                            cpSolver.addFixComponentRestriction(compId, vmIndex)
                    vmIndex += 1

            #add restrictia de conflict
            #-sorteaza descrescator in functie de caracteristicele masini
            compHardwareRequirments = []
            for compId in componentsThatCouldBeMoved:
                compHardwareRequirments.append([compId, self.problem.componentsList[compId].getResorces()])

            sorted(compHardwareRequirments, key=self.__sortCriteria, reverse=True)


            print("compHardwareRequirments", compHardwareRequirments)

            #v1 - in conflict cea cu resursele cele mai mari cu urmatoarea
            cpSolver.RestrictionConflict(compHardwareRequirments[0][0], [compHardwareRequirments[1][0]])

            # v2 - in conflict cea cu resursele cele mai mari cu toate restul
            #cpSolver.RestrictionConflict(compHardwareRequirments[0], compHardwareRequirments[1:])

            # v3 - in conflict 2 cu 2
            # for i in range(0, len(componentsThatCouldBeMoved), 2):
            #      cpSolver.RestrictionConflict(compHardwareRequirments[i], compHardwareRequirments[i+1])

            print (mostLoadedVmId, componentsThatCouldBeMoved, newVmNr, element.a)

            objectiveValue, _costVector, _vm, allocation = cpSolver.run()
            print("@@@@@@@@@@", objectiveValue, _costVector, _vm, allocation)



        #aici pornesc de la problema initiala de cp
            if len(allocation) > 0: # a gasit o noua solutie
                element.reset_solution_initialization()
                for i in range(len(allocation)):
                    for j in range(len(allocation[0])):
                        if allocation[i][j] == 1:
                            element.addCompToVM(i, j)
                return True, element
        return False, element


    def mutation_with_cp_addConflict(self, mostLoadedVmId, element):
        """ - bin packing
        Use CP to split most loaded VM
        :param mostLoadedVmId: the vmId with most components
        :param element: the mutated_element
        :return: True if a solution is found
        """
        # analyze components deployed on that machine
        # 1. full deployment
        # 2. collocation
        componentsThatCouldBeMoved = set()
        for compId in element.solVms[mostLoadedVmId]:
            if not self.problem.componentsList[compId].fullDeployedComponent:  # nu e full deployment
                #if len(self.problem.componentsList[compId].dependenceComponentsList) == 0:  # nu trebuie colocata cu alta componenta
                    componentsThatCouldBeMoved.add(compId)

        if len(componentsThatCouldBeMoved) > 1:
            # ne uitam daca putem sa modificam numarul total de masini
            #newVmNr = len(element.vms) + len(componentsThatCouldBeMoved) #daca masinile sunt identice si pun conflicte intre 2 atunci imi trebuie mai multe
            newVmNr = self.problem.nrVM
            #acu incepe cp-ul
            from maneuverRecomadEngine.exactsolvers import CP_Solver_GOT
            cpSolver = CP_Solver_GOT.CP_Solver_Got(self.problem, "FIRST_UNBOUND_MIN", 10, True,
                                                   None, 100000, newVmNr)

            for restriction in self.problem.restrictionsList:
                restriction.generateRestrictions(cpSolver)


            vmIndex = 0
            for vmId in element.vms:
                if vmId != mostLoadedVmId:
                    for compId in element.solVms[vmId]:
                        if compId not in componentsThatCouldBeMoved:
                            cpSolver.addFixComponentRestriction(compId, vmIndex)
                    vmIndex += 1

            #add restrictia de conflict
            #-sorteaza descrescator in functie de caracteristicele masini
            compHardwareRequirments = []
            for compId in componentsThatCouldBeMoved:
                compHardwareRequirments.append([compId, self.problem.componentsList[compId].getResorces()])

            sorted(compHardwareRequirments, key=self.__sortCriteria, reverse=True)


            print("compHardwareRequirments", compHardwareRequirments)

            #v1 - in conflict cea cu resursele cele mai mari cu urmatoarea
            cpSolver.RestrictionConflict(compHardwareRequirments[0][0], [compHardwareRequirments[1][0]])

            # v2 - in conflict cea cu resursele cele mai mari cu toate restul
            # cpSolver.RestrictionConflict(compHardwareRequirments[0], compHardwareRequirments[1:])

            # v3 - in conflict 2 cu 2
            # for i in range(0, len(componentsThatCouldBeMoved), 2):
            #      cpSolver.RestrictionConflict(compHardwareRequirments[i], compHardwareRequirments[i+1])

            print (mostLoadedVmId, componentsThatCouldBeMoved, newVmNr, element.a)

            objectiveValue, _costVector, _vm, allocation = cpSolver.run()
            print("@@@@@@@@@@", objectiveValue, _costVector, _vm, allocation)



        #aici pornesc de la problema initiala de cp
            if len(allocation) > 0: # a gasit o noua solutie
                element.reset_solution_initialization()
                for i in range(len(allocation)):
                    for j in range(len(allocation[0])):
                        if allocation[i][j] == 1:
                            element.addCompToVM(i, j)
                return True, element
        return False, element



    def mutation_with_cp_faraCP(self, mostLoadedVmId, element):
        """ - bin packing
        Use CP to split most loaded VM
        :param mostLoadedVmId: the vmId with most components
        :param element: the mutated_element
        :return: True if a solution is found
        """
        # analyze components deployed on that machine
        # 1. full deployment
        # 2. collocation
        componentsThatCouldBeMoved = set()
        for compId in element.solVms[mostLoadedVmId]:
            if not self.problem.componentsList[compId].fullDeployedComponent:  # nu e full deployment
                #if len(self.problem.componentsList[compId].dependenceComponentsList) == 0:  # nu trebuie colocata cu alta componenta
                    componentsThatCouldBeMoved.add(compId)

        if len(componentsThatCouldBeMoved) > 1:
            # ne uitam daca putem sa modificam numarul total de masini
            #newVmNr = len(element.vms) + len(componentsThatCouldBeMoved) #daca masinile sunt identice si pun conflicte intre 2 atunci imi trebuie mai multe
            newVmNr = self.problem.nrVM

            #add restrictia de conflict
            #-sorteaza descrescator in functie de caracteristicele masini
            compHardwareRequirments = []
            for compId in componentsThatCouldBeMoved:
                compHardwareRequirments.append([compId, self.problem.componentsList[compId].getResorces()])

            sorted(compHardwareRequirments, key=self.__sortCriteria, reverse=True)



                #return True, element
        return False, element


    def __mutate(self, element, nr_of_repetions):
        mutate_element = element.copy()
        # compute frequencies vectors for vm selection
        vms_vector = []
        max_nr_of_components = 0.0
        id_vm_with_max_components_nr = -1 # a value that is not a valid id for component
        total_nr_of_deployed_components = 0.0

        for vmId, vm_compsList in mutate_element.solVms.items():
            _vm = EvolutionaryAlgorithm.VM(vmId)
            _vm.nrOfComponents = float(len(vm_compsList))
            if _vm.nrOfComponents > max_nr_of_components:
                max_nr_of_components = _vm.nrOfComponents
                id_vm_with_max_components_nr = vmId

            vms_vector.append(_vm)
            total_nr_of_deployed_components += _vm.nrOfComponents

        s = 0
        for _vm in vms_vector:
            _vm.frequencyMostLoadedComponents = _vm.nrOfComponents / total_nr_of_deployed_components
            _vm.frequencyLessLoadedComponents = (max_nr_of_components - _vm.nrOfComponents + self.EPSILON)
            s += _vm.frequencyLessLoadedComponents

        for _vm in vms_vector:
            _vm.frequencyLessLoadedComponents /= s

        # #try to split vm
        # if mutate_element.violatedConstraintsNr == 0:
        #     success, mutate_element = self.mutation_with_cp(id_vm_with_max_components_nr, mutate_element)
        #
        #     if success:
        #         self.sucessMutationCP += 1
        #         mutate_element.eval()
        #         if mutate_element.elementCost < element.elementCost:
        #             self.betterSolutionFromMutationCP += 1
        #         #print(mutate_element.solVms)
        #         return mutate_element, success
        #
        # mutate_element = element.copy()

        # move component
        success = False
        tries = 0
        vm_from_index = self.__proportional_selection_vm(vms_vector, True) #DONE!!cea mai plina
        #print("vm_from_index: ", vm_from_index, mutate_element.solVms)
        vm_from_comp_index = self.__proportional_selection_comp_from_vm(mutate_element.solVms[vm_from_index])

        # 1. try to move a component from a machine to other machine
        while (not success) and (tries < nr_of_repetions):
            tries += 1
            vm_to_index = self.__proportional_selection_vm(vms_vector, False) #DONE!!cea mai goala
            # look if it is in conflict with components from machine
            if self.__canComponentBeMovedToVm(vm_from_comp_index, vm_to_index, mutate_element):
                self.__moveComponentToVm(vm_from_comp_index, vm_from_index, vm_to_index, mutate_element)
                success = True

            #print("finish move, sucess=", success)
            # 1. try to swap a component from a machine to other machine
            if not success:  # try to swap
                #!!ar trebui sa ma uit pe cea selectata setul de componente cu care nu e in conflict
                vm_to_index = self.__uniform_selection_vm(vms_vector) #DONE!!selectie uniform aleatoare sau orice altceva
                vm_to_comp_index = self.__proportional_selection_comp_from_vm(mutate_element.solVms[vm_to_index])
                # look if it is in conflict with components from machine
                if self.__canComponentBeMovedToVm(vm_from_comp_index, vm_to_index, mutate_element) and \
                        self.__canComponentBeMovedToVm(vm_to_comp_index, vm_from_index, mutate_element):
                    self.__moveComponentToVm(vm_from_comp_index, vm_from_index, vm_to_index, mutate_element)
                    self.__moveComponentToVm(vm_to_comp_index, vm_to_index, vm_from_index, mutate_element)

                    success = True

            #print("finish swap, sucess=", success)
            #print("mutated el end : ", mutate_element.solVms, mutate_element.solComponents)


        # if no offer is found try to move components to new machines
        # if not success and len(mutate_element.noOfferFond) > 0: #doar daca nu au intrat in mutatie mai sus
        #     for vmId in mutate_element.noOfferFond:
        #         # allVm = set()
        #         # for i in range(self.problem.nrVM):
        #         #     allVm.add(i)
        #         # freeVms = allVm.difference(mutate_element.vms)  # DONE!!!ia una goala daca exista
        #         # if len(freeVms) > 0:
        #         #     new_vm = freeVms.pop()
        #         #     vm_from_comp_index = self.__proportional_selection_comp_from_vm(
        #         #             mutate_element.solVms[vmId])
        #         #     self.__moveComponentToVm(vm_from_comp_index, vmId, new_vm, mutate_element)
        #         #     success = True
        #
        #         # #try to split vm
        #         if mutate_element.violatedConstraintsNr == 0:
        #             success, mutate_element = self.mutation_with_cp(id_vm_with_max_components_nr, mutate_element)
        #
        #             if success:
        #                 self.sucessMutationCP += 1
        #                 mutate_element.eval()
        #                 if mutate_element.elementCost < element.elementCost:
        #                     self.betterSolutionFromMutationCP += 1
        #                 #print(mutate_element.solVms)
        #                 return mutate_element, success


        if not success and random.random() < self.probability_to_add_a_new_vm: #!!!parametrizabil 0.25
            allVm = set()
            for i in range(self.problem.nrVM):
                allVm.add(i)
            freeVms = allVm.difference(mutate_element.vms) #DONE!!!ia una goala daca exista
            if len(freeVms) > 0:
                new_vm = freeVms.pop()
                self.__moveComponentToVm(vm_from_comp_index, vm_from_index, new_vm, mutate_element)
                success = True
        # elif not success and random.random() < self.probability_to_add_a_new_vm:
        #     success, mutate_element = self.mutation_with_cp_addConflict(id_vm_with_max_components_nr, mutate_element)
        #
        #     if success:
        #         self.sucessMutationCP += 1
        #         mutate_element.eval()
        #         if mutate_element.elementCost < element.elementCost:
        #             self.betterSolutionFromMutationCP += 1
        #         # print(mutate_element.solVms)
        #         return mutate_element, success

        if success:
            mutate_element.howManyTimesANewElemetIsCreatedFromCurrentOne += 1
        return mutate_element, success

    def __canComponentBeMovedToVm(self, componentId, targetVm, element):
        """
        Verifies if component 'componentId' can be moved to target Vm:
        - target vm does not contain components that are in conflict with component
        - target vm doe not contain components that are in conflict with components that depends on current componnent
        :param componentId: component id
        :param targetVm:  target vm id
        :param element: the population element on which the mutation is done
        :return: True if conmonent can be moved, false othweis
        """
        #print("targetVm", targetVm, element.solVms)
        for compId in element.solVms[targetVm]:
            if compId in self.problem.componentsList[componentId].conflictComponentsList:
                return False
        if len(self.problem.componentsList[componentId].dependenceComponentsList) > 0:
            for dependent_compId in self.problem.componentsList[componentId].dependenceComponentsList:
                for compId in element.solVms[targetVm]:
                    if compId in self.problem.componentsList[dependent_compId].conflictComponentsList:
                        return False
        return True

    def __moveComponentToVm(self, componentId, sourceVm, targetVm, element):
        """
        Move component with id 'componentId' and its dependences from source vm to target vm
        :param componentId: the id of the component
        :param sourceVm: the id of source vm
        :param targetVm: the id of target vm
        :param element: EA element on witch the move is performed
        :return: None
        """
        element.removeCompFromVM(componentId, sourceVm)
        element.addCompToVM(componentId, targetVm)
        for dependent_compId in self.problem.componentsList[componentId].dependenceComponentsList:
            if element.isComponentOnMachine(dependent_compId, sourceVm):
                element.removeCompFromVM(dependent_compId, sourceVm)
            element.addCompToVM(dependent_compId, targetVm)

    def __select(self, el1, el2, addInfo, success_mutation):
        """
        Selects best element on the following criteria: less violated constraints, less virtual machines used, less
        components deployed
        :param el1: first element  to be compared
        :param el2: second element to be compared
        :return the best element from the 2 elements
        """

        if el1.violatedConstraintsNr == el2.violatedConstraintsNr:
            if el1.violatedConstraintsNr == 0:

                if el1.elementCost >= el2.elementCost:

                    if addInfo:
                        if success_mutation: el2.numberOfSucessMutations += 1
                        #print("el1.cost ", el1.elementCost, "el2.cost ", el2.elementCost,  el2.numberOfSucessMutations )
                    return el2
                else:
                    return el1
            if el1.vmsNr == el2.vmsNr:
                if el1.componentsNr < el2.componentsNr:
                    return el1
                else:
                    if addInfo:
                        if success_mutation: el2.numberOfSucessMutations += 1
                    return el2
            elif el1.vmsNr < el2.vmsNr:
                return el1
            else:
                if addInfo:
                    if success_mutation: el2.numberOfSucessMutations += 1
                return el2
        elif el1.violatedConstraintsNr < el2.violatedConstraintsNr:
            return el1
        else:
            if addInfo:
                if success_mutation: el2.numberOfSucessMutations += 1
            return el2


    def __crossover(self):
        """
        self.newPopulation = []
        for i in range(int(self.populationSize/2)):
            p1 = int(random.random() * self.populationSize)
            p2 = int(random.random() * self.populationSize)
            newEl1 = Element(self.problem)
            newEl2 = Element(self.problem)
            for i in range(self.problem.nrComp):
                for j in range(self.problem.nrVM):
                    if random.random() < 0.5:
                        self.__addRemove(newEl1, self.population[p1].a[i][j], i, j)
                        self.__addRemove(newEl2, self.population[p2].a[i][j], i, j)
                    else:
                        self.__addRemove(newEl1, self.population[p2].a[i][j], i, j)
                        self.__addRemove(newEl2, self.population[p1].a[i][j], i, j)
            newEl2.repair()
            newEl2.eval()

            newEl1.repair()
            newEl1.eval()

            self.newPopulation.append(newEl1)
            self.newPopulation.append(newEl2)
        """

    def getSolution(self):
        """
        Finds the best solution in the current population and verifies if is the same with the one from
        previous generation
        :return: None
        """
        _min = self.population[0]
        for element in self.population:
            _min = self.__select(_min, element, False, False)

        #print(_min)

        if self.bestElement is not None:
            bestElPrice = 0
            minElPrice = 0
            #print(min.vmsPrice)
            for vm, price in self.bestElement.vmsPrice.items():
                bestElPrice += price
            for vm, price in _min.vmsPrice.items():
                minElPrice += price

            # if self.bestElement.violatedConstraintsNr == _min.violatedConstraintsNr and \
            #                 self.bestElement.vmsNr == _min.vmsNr and self.bestElement.componentsNr == _min.componentsNr:
            #     self.stagnationSteps += 1
            # else:
            #     self.stagnationSteps = 0
            #     self.bestElement = _min.copy()

            if bestElPrice == minElPrice:
                self.stagnationSteps += 1
            else:
                self.stagnationSteps = 0
                self.bestElement = _min.copy()
        else:
            self.bestElement = _min.copy()

        return self.bestElement.vmsNr, self.bestElement.elementCost, self.bestElement.violatedConstraintsNr, \
               self.bestElement.a, self.bestElement.vmsPrice, self.doneIterations, self.stagnationSteps, self.successMuations, \
               self.sucessMutationCP, self.betterSolutionFromMutationCP
